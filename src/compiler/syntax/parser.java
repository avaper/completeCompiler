
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Tue Jun 09 08:04:49 CEST 2020
//----------------------------------------------------

package compiler.syntax;

import java_cup.runtime.Symbol;
import java.util.*;
import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;
import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Tue Jun 09 08:04:49 CEST 2020
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\146\000\002\002\004\000\002\050\002\000\002\002" +
    "\004\000\002\051\002\000\002\003\007\000\002\003\004" +
    "\000\002\004\004\000\002\004\002\000\002\005\004\000" +
    "\002\005\003\000\002\006\006\000\002\006\003\000\002" +
    "\007\003\000\002\007\003\000\002\007\003\000\002\010" +
    "\004\000\002\010\002\000\002\011\004\000\002\011\003" +
    "\000\002\012\006\000\002\012\003\000\002\013\005\000" +
    "\002\013\003\000\002\014\004\000\002\014\003\000\002" +
    "\015\006\000\002\015\006\000\002\015\003\000\002\016" +
    "\004\000\002\016\002\000\002\017\004\000\002\017\003" +
    "\000\002\020\006\000\002\020\003\000\002\021\003\000" +
    "\002\021\003\000\002\022\006\000\002\022\002\000\002" +
    "\023\006\000\002\023\003\000\002\024\004\000\002\024" +
    "\005\000\002\024\002\000\002\025\005\000\002\025\003" +
    "\000\002\026\006\000\002\026\003\000\002\027\004\000" +
    "\002\027\002\000\002\027\003\000\002\030\005\000\002" +
    "\030\002\000\002\030\003\000\002\031\003\000\002\031" +
    "\003\000\002\031\003\000\002\031\004\000\002\031\004" +
    "\000\002\031\003\000\002\031\003\000\002\032\005\000" +
    "\002\032\007\000\002\041\006\000\002\037\007\000\002" +
    "\040\004\000\002\040\002\000\002\033\006\000\002\033" +
    "\006\000\002\033\003\000\002\034\004\000\002\035\006" +
    "\000\002\035\003\000\002\036\003\000\002\036\005\000" +
    "\002\036\005\000\002\036\007\000\002\036\002\000\002" +
    "\036\003\000\002\042\004\000\002\042\005\000\002\042" +
    "\005\000\002\042\005\000\002\042\005\000\002\042\005" +
    "\000\002\042\005\000\002\042\003\000\002\042\003\000" +
    "\002\042\003\000\002\042\003\000\002\042\005\000\002" +
    "\042\006\000\002\042\003\000\002\043\003\000\002\043" +
    "\003\000\002\046\003\000\002\046\005\000\002\044\010" +
    "\000\002\044\003\000\002\045\006\000\002\045\003\000" +
    "\002\047\003\000\002\047\004" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\257\000\004\020\000\001\002\000\004\002\261\001" +
    "\002\000\004\020\007\001\002\000\004\002\uffff\001\002" +
    "\000\006\003\010\010\011\001\002\000\004\002\ufffc\001" +
    "\002\000\004\036\ufffe\001\002\000\004\036\014\001\002" +
    "\000\016\003\016\013\ufffa\021\ufffa\031\017\034\ufffa\035" +
    "\ufffa\001\002\000\044\002\uff9d\003\uff9d\010\uff9d\013\uff9d" +
    "\014\uff9d\015\uff9d\017\uff9d\021\uff9d\022\uff9d\024\uff9d\025" +
    "\uff9d\026\uff9d\027\uff9d\031\uff9d\034\uff9d\035\uff9d\036\014" +
    "\001\002\000\042\002\uff9c\003\uff9c\010\uff9c\013\uff9c\014" +
    "\uff9c\015\uff9c\017\uff9c\021\uff9c\022\uff9c\024\uff9c\025\uff9c" +
    "\026\uff9c\027\uff9c\031\uff9c\034\uff9c\035\uff9c\001\002\000" +
    "\010\002\uffa0\013\uffa0\021\uffa0\001\002\000\006\003\246" +
    "\010\247\001\002\000\012\013\ufff1\021\ufff1\034\023\035" +
    "\ufff1\001\002\000\004\002\ufffd\001\002\000\010\013\uffe4" +
    "\021\uffe4\035\053\001\002\000\006\003\024\010\027\001" +
    "\002\000\014\003\uffed\010\uffed\013\uffed\021\uffed\035\uffed" +
    "\001\002\000\014\003\024\010\027\013\uffef\021\uffef\035" +
    "\uffef\001\002\000\010\013\ufff2\021\ufff2\035\ufff2\001\002" +
    "\000\004\043\030\001\002\000\006\003\032\033\033\001" +
    "\002\000\004\036\014\001\002\000\004\036\uffeb\001\002" +
    "\000\006\003\035\010\037\001\002\000\004\014\050\001" +
    "\002\000\010\003\uffe6\010\uffe6\014\uffe6\001\002\000\010" +
    "\003\035\010\037\014\uffe9\001\002\000\004\042\040\001" +
    "\002\000\010\010\043\030\044\032\041\001\002\000\006" +
    "\036\uffa5\040\uffa5\001\002\000\004\036\014\001\002\000" +
    "\004\036\014\001\002\000\006\036\uffa4\040\uffa4\001\002" +
    "\000\010\003\uffe7\010\uffe7\014\uffe7\001\002\000\010\003" +
    "\uffe8\010\uffe8\014\uffe8\001\002\000\004\014\uffea\001\002" +
    "\000\004\036\uffec\001\002\000\014\003\uffee\010\uffee\013" +
    "\uffee\021\uffee\035\uffee\001\002\000\010\013\ufff0\021\ufff0" +
    "\035\ufff0\001\002\000\006\003\236\010\103\001\002\000" +
    "\006\013\uffdc\021\uffdc\001\002\000\006\013\056\021\057" +
    "\001\002\000\024\003\127\010\123\014\uffce\015\130\022" +
    "\120\024\132\025\126\026\121\027\117\001\002\000\006" +
    "\003\060\010\062\001\002\000\016\003\uffda\013\uffda\021" +
    "\uffda\031\uffda\034\uffda\035\uffda\001\002\000\016\003\016" +
    "\013\ufffa\021\ufffa\031\017\034\ufffa\035\ufffa\001\002\000" +
    "\012\003\uffd7\036\uffd7\037\063\042\uffd7\001\002\000\010" +
    "\003\074\035\073\040\072\001\002\000\010\003\066\036" +
    "\uffd1\042\067\001\002\000\004\036\014\001\002\000\004" +
    "\036\uffd0\001\002\000\006\030\044\032\041\001\002\000" +
    "\004\036\uffd2\001\002\000\016\003\uffdb\013\uffdb\021\uffdb" +
    "\031\uffdb\034\uffdb\035\uffdb\001\002\000\010\003\uffd9\036" +
    "\uffd9\042\uffd9\001\002\000\004\010\103\001\002\000\006" +
    "\036\uffd3\040\uffd3\001\002\000\004\040\101\001\002\000" +
    "\006\036\014\040\uffd5\001\002\000\006\003\074\035\073" +
    "\001\002\000\004\040\uffd6\001\002\000\010\003\uffd8\036" +
    "\uffd8\042\uffd8\001\002\000\004\042\106\001\002\000\006" +
    "\041\104\042\uffa3\001\002\000\004\010\103\001\002\000" +
    "\004\042\uffa2\001\002\000\010\010\111\030\044\032\041" +
    "\001\002\000\006\036\uffd4\040\uffd4\001\002\000\006\036" +
    "\uffdf\040\uffdf\001\002\000\006\036\uffde\040\uffde\001\002" +
    "\000\006\013\uffdd\021\uffdd\001\002\000\004\036\uffc7\001" +
    "\002\000\004\014\235\001\002\000\004\036\uffca\001\002" +
    "\000\004\014\234\001\002\000\004\036\uffbd\001\002\000" +
    "\020\003\136\004\140\005\135\006\134\010\142\012\137" +
    "\037\141\001\002\000\004\037\230\001\002\000\004\036" +
    "\uffcb\001\002\000\012\036\uffba\037\217\046\220\051\221" +
    "\001\002\000\004\036\uffcc\001\002\000\004\036\014\001" +
    "\002\000\004\037\212\001\002\000\014\002\uff9e\013\uff9e" +
    "\014\uffcd\021\uff9e\036\uffc6\001\002\000\020\003\136\004" +
    "\140\005\135\006\134\010\142\012\137\037\141\001\002" +
    "\000\004\014\201\001\002\000\020\003\136\004\140\005" +
    "\135\006\134\010\142\012\137\037\141\001\002\000\010" +
    "\002\uffa1\013\uffa1\021\uffa1\001\002\000\024\011\uffac\016" +
    "\uffac\023\uffac\036\uffac\040\uffac\044\uffac\045\uffac\047\uffac" +
    "\050\uffac\001\002\000\024\011\uffaa\016\uffaa\023\uffaa\036" +
    "\uffaa\040\uffaa\044\uffaa\045\uffaa\047\uffaa\050\uffaa\001\002" +
    "\000\024\011\uffa6\016\uffa6\023\uffa6\036\uffa6\040\uffa6\044" +
    "\uffa6\045\uffa6\047\uffa6\050\uffa6\001\002\000\020\003\136" +
    "\004\140\005\135\006\134\010\142\012\137\037\141\001" +
    "\002\000\024\011\uffab\016\uffab\023\uffab\036\uffab\040\uffab" +
    "\044\uffab\045\uffab\047\uffab\050\uffab\001\002\000\020\003" +
    "\136\004\140\005\135\006\134\010\142\012\137\037\141" +
    "\001\002\000\030\011\uffa9\016\uffa9\023\uffa9\036\uffa9\037" +
    "\161\040\uffa9\044\uffa9\045\uffa9\047\uffa9\050\uffa9\051\162" +
    "\001\002\000\016\011\150\023\151\044\146\045\145\047" +
    "\144\050\147\001\002\000\020\003\136\004\140\005\135" +
    "\006\134\010\142\012\137\037\141\001\002\000\020\003" +
    "\136\004\140\005\135\006\134\010\142\012\137\037\141" +
    "\001\002\000\020\003\136\004\140\005\135\006\134\010" +
    "\142\012\137\037\141\001\002\000\020\003\136\004\140" +
    "\005\135\006\134\010\142\012\137\037\141\001\002\000" +
    "\020\003\136\004\140\005\135\006\134\010\142\012\137" +
    "\037\141\001\002\000\024\003\152\010\123\014\uffce\015" +
    "\130\022\120\024\132\025\126\026\121\027\117\001\002" +
    "\000\010\014\uffcd\017\uffcd\036\uffc6\001\002\000\004\014" +
    "\uffc3\001\002\000\024\011\uffaf\016\uffaf\023\uffaf\036\uffaf" +
    "\040\uffaf\044\uffaf\045\uffaf\047\uffaf\050\uffaf\001\002\000" +
    "\020\011\150\016\uffad\023\uffad\036\uffad\040\uffad\044\146" +
    "\045\145\001\002\000\024\011\150\016\uffb0\023\uffb0\036" +
    "\uffb0\040\uffb0\044\uffb0\045\145\047\uffb0\050\uffb0\001\002" +
    "\000\024\011\uffb1\016\uffb1\023\uffb1\036\uffb1\040\uffb1\044" +
    "\uffb1\045\uffb1\047\uffb1\050\uffb1\001\002\000\020\011\150" +
    "\016\uffae\023\uffae\036\uffae\040\uffae\044\146\045\145\001" +
    "\002\000\010\003\164\010\165\040\uffb5\001\002\000\004" +
    "\010\163\001\002\000\024\011\uffa8\016\uffa8\023\uffa8\036" +
    "\uffa8\040\uffa8\044\uffa8\045\uffa8\047\uffa8\050\uffa8\001\002" +
    "\000\004\040\uffb4\001\002\000\010\040\uffb9\041\171\051" +
    "\170\001\002\000\004\040\167\001\002\000\024\011\uffa7" +
    "\016\uffa7\023\uffa7\036\uffa7\040\uffa7\044\uffa7\045\uffa7\047" +
    "\uffa7\050\uffa7\001\002\000\004\010\173\001\002\000\010" +
    "\003\164\010\165\040\uffb5\001\002\000\004\040\uffb8\001" +
    "\002\000\006\040\uffb7\041\174\001\002\000\010\003\164" +
    "\010\165\040\uffb5\001\002\000\004\040\uffb6\001\002\000" +
    "\016\011\150\040\177\044\146\045\145\047\144\050\147" +
    "\001\002\000\024\011\uffb2\016\uffb2\023\uffb2\036\uffb2\040" +
    "\uffb2\044\uffb2\045\uffb2\047\uffb2\050\uffb2\001\002\000\024" +
    "\011\uffb3\016\uffb3\023\uffb3\036\uffb3\040\uffb3\044\uffb3\045" +
    "\uffb3\047\uffb3\050\uffb3\001\002\000\004\010\202\001\002" +
    "\000\004\036\014\001\002\000\010\002\uff9f\013\uff9f\021" +
    "\uff9f\001\002\000\016\011\150\016\205\044\146\045\145" +
    "\047\144\050\147\001\002\000\026\003\152\010\123\014" +
    "\uffce\015\130\017\uffce\022\120\024\132\025\126\026\121" +
    "\027\117\001\002\000\006\014\uffc0\017\210\001\002\000" +
    "\004\014\uffc2\001\002\000\024\003\152\010\123\014\uffce" +
    "\015\130\022\120\024\132\025\126\026\121\027\117\001" +
    "\002\000\004\014\uffc1\001\002\000\004\007\213\001\002" +
    "\000\004\040\214\001\002\000\004\036\uffbf\001\002\000" +
    "\026\003\152\010\123\014\uffce\015\130\017\uffce\022\120" +
    "\024\132\025\126\026\121\027\117\001\002\000\006\014" +
    "\uffcf\017\uffcf\001\002\000\010\003\164\010\165\040\uffb5" +
    "\001\002\000\020\003\136\004\140\005\135\006\134\010" +
    "\142\012\137\037\141\001\002\000\004\010\222\001\002" +
    "\000\004\046\223\001\002\000\020\003\136\004\140\005" +
    "\135\006\134\010\142\012\137\037\141\001\002\000\016" +
    "\011\150\036\uffc4\044\146\045\145\047\144\050\147\001" +
    "\002\000\016\011\150\036\uffc5\044\146\045\145\047\144" +
    "\050\147\001\002\000\004\040\227\001\002\000\004\036" +
    "\uffbb\001\002\000\020\003\136\004\140\005\135\006\134" +
    "\010\142\012\137\037\141\001\002\000\016\011\150\040" +
    "\232\044\146\045\145\047\144\050\147\001\002\000\004" +
    "\036\uffbe\001\002\000\016\011\150\036\uffbc\044\146\045" +
    "\145\047\144\050\147\001\002\000\004\036\uffc9\001\002" +
    "\000\004\036\uffc8\001\002\000\012\003\uffe0\010\uffe0\013" +
    "\uffe0\021\uffe0\001\002\000\012\003\236\010\103\013\uffe2" +
    "\021\uffe2\001\002\000\004\042\242\001\002\000\006\013" +
    "\uffe5\021\uffe5\001\002\000\010\010\111\030\044\032\041" +
    "\001\002\000\004\036\014\001\002\000\012\003\uffe1\010" +
    "\uffe1\013\uffe1\021\uffe1\001\002\000\006\013\uffe3\021\uffe3" +
    "\001\002\000\016\003\ufff6\010\ufff6\013\ufff6\021\ufff6\034" +
    "\ufff6\035\ufff6\001\002\000\004\043\253\001\002\000\012" +
    "\013\ufffb\021\ufffb\034\ufffb\035\ufffb\001\002\000\016\003" +
    "\246\010\247\013\ufff8\021\ufff8\034\ufff8\035\ufff8\001\002" +
    "\000\012\013\ufff9\021\ufff9\034\ufff9\035\ufff9\001\002\000" +
    "\010\004\257\005\255\006\254\001\002\000\004\036\ufff3" +
    "\001\002\000\004\036\ufff4\001\002\000\004\036\014\001" +
    "\002\000\004\036\ufff5\001\002\000\016\003\ufff7\010\ufff7" +
    "\013\ufff7\021\ufff7\034\ufff7\035\ufff7\001\002\000\004\002" +
    "\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\257\000\006\002\003\050\004\001\001\000\002\001" +
    "\001\000\004\003\005\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\051\011\001\001\000" +
    "\004\047\012\001\001\000\006\004\017\044\020\001\001" +
    "\000\004\047\014\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\005\247\006\250\001\001\000\004\010\021" +
    "\001\001\000\002\001\001\000\004\016\053\001\001\000" +
    "\006\011\025\012\024\001\001\000\002\001\001\000\006" +
    "\011\051\012\024\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\013\030\001\001\000\004\047\050\001\001" +
    "\000\002\001\001\000\006\014\033\015\035\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\014\046\015\035" +
    "\001\001\000\002\001\001\000\004\043\041\001\001\000" +
    "\002\001\001\000\004\047\045\001\001\000\004\047\044" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\010\017\240\020\236\046\237\001" +
    "\001\000\004\022\054\001\001\000\002\001\001\000\024" +
    "\030\130\031\124\032\123\033\121\034\114\035\112\037" +
    "\115\041\113\045\132\001\001\000\004\023\060\001\001" +
    "\000\002\001\001\000\006\004\017\044\111\001\001\000" +
    "\004\024\063\001\001\000\006\025\074\026\075\001\001" +
    "\000\004\027\064\001\001\000\004\047\070\001\001\000" +
    "\002\001\001\000\004\043\067\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\046\101\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\047\076" +
    "\001\001\000\006\025\077\026\075\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\046\104\001\001\000\002\001\001\000\006\021" +
    "\106\043\107\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\042\232\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\047\214\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\042\203\001\001\000\002\001\001\000\004\042\142" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\042\177\001\001\000\002" +
    "\001\001\000\004\042\175\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\042\157\001\001\000\004\042\156" +
    "\001\001\000\004\042\155\001\001\000\004\042\154\001" +
    "\001\000\004\042\153\001\001\000\022\030\152\031\124" +
    "\032\123\033\121\034\114\035\112\037\115\041\113\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\036\165\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\036\171\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\036\174\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\047\202\001\001\000\002\001\001\000\002\001\001" +
    "\000\022\030\205\031\124\032\123\033\121\034\114\035" +
    "\112\037\115\041\113\001\001\000\004\040\206\001\001" +
    "\000\002\001\001\000\022\030\210\031\124\032\123\033" +
    "\121\034\114\035\112\037\115\041\113\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\022\030\215\031\124\032\123\033\121\034\114" +
    "\035\112\037\115\041\113\001\001\000\002\001\001\000" +
    "\004\036\225\001\001\000\004\042\224\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\042\223\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\042\230\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\010\017\244\020\236\046" +
    "\237\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\021\242\043\107\001\001\000\004\047\243\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\005\251\006\250\001" +
    "\001\000\002\001\001\000\004\007\255\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\047\257\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {


	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

	LabelFactory lf = new LabelFactory();
	List<QuadrupleIF> stringList = new ArrayList<QuadrupleIF>();
	HashMap<String, String> calls = new HashMap<String, String>();

	int nesting = 0;

  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // ntPtoComa ::= TPTOCOMA ntPtoComa 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ntPtoComa",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // ntPtoComa ::= TPTOCOMA 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ntPtoComa",37, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // finalModulo ::= error 
            {
              Sentencias RESULT =null;
		 semanticErrorManager.semanticFatalError("Error en el final del modulo"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("finalModulo",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // finalModulo ::= sentencias TEND TIDENTIFICADOR ntPtoComa 
            {
              Sentencias RESULT =null;
		int sentsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int sentsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Sentencias sents = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		

		// COMPROBACIONES SEMANTICAS

			ScopeIF scope = scopeManager.getCurrentScope();
			SymbolIF symbol = scopeManager.searchSymbol(id.getLexema().toUpperCase());

			if ( symbol != null && symbol.getType() instanceof TypeFunction && !sents.isReturnContained() ) semanticErrorManager.semanticFatalError("Funcion " + scopeManager.getCurrentScope().getName() +  " sin RETURN");

			if ( symbol != null && symbol.getType() instanceof TypeFunction && !sents.isBalanced() ) semanticErrorManager.semanticFatalError("Funcion " + scopeManager.getCurrentScope().getName() +  " mal balanceada (RETURN)");

			if ( ! scopeManager.getCurrentScope().getName().equals(id.getLexema().toUpperCase())) semanticErrorManager.semanticFatalError("Cierre de ambito " + scopeManager.getCurrentScope().getName() + " invalido");																					
	
			scopeManager.closeScope();

		// CODIGO INTERMEDIO

			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);

			if ( scope.getLevel() == 0 )
			{		
				cb.addQuadruples(sents.getIntermediateCode());		
				cb.addQuadruple("HALT");
			}
			else
			{
				LabelIF labelFin = new Label("L_FIN_" + scope.getParentScope().getName() + "_" + scope.getName(), symbol.getType());
	
				int size = ((TypeProcedure) symbol.getType()).getNumParams() + 5;

				cb.addQuadruples(sents.getIntermediateCode());
				cb.addQuadruple("LEAVE", labelFin, size);
			}

			sents.setIntermediateCode(cb.create());
			sents.setScope(scope);

			RESULT = sents;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("finalModulo",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // cuerpoModulo ::= error 
            {
              Sentencias RESULT =null;
		 semanticErrorManager.semanticFatalError("Error en el cuerpo del modulo"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpoModulo",34, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // cuerpoModulo ::= ctes tipos vars subs TBEGIN finalModulo 
            {
              Sentencias RESULT =null;
		int suleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int suright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Sentencias su = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int fmleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fmright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencias fm = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

		// CODIGO INTERMEDIO

			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(fm.getScope());
			TemporalFactoryIF tf = new TemporalFactory(fm.getScope());

			if ( fm.getScope().getLevel() != 0 )
			{
				TemporalIF temp = tf.create();
				LabelIF labelIni = lf.create(fm.getScope().getParentScope().getName() + "_" + fm.getScope().getName());

				cb.addQuadruple("SUBROUTINE", labelIni);
	
				int size = fm.getScope().getTemporalTable().getSize() + 5;

				for ( SymbolIF symbol: fm.getScope().getSymbolTable().getSymbols() )
				{
					if ( symbol instanceof SymbolVariable ) 
					{
						cb.addQuadruple("SUBROUTINEVARIABLE", symbol.getName(), 0);		
					}

					size += symbol.getType().getSize();
				}

				cb.addQuadruple("SUBROUTINEPOINTER", temp, size);
			}

			cb.addQuadruples(fm.getIntermediateCode());
			cb.addQuadruples(su.getIntermediateCode());

			fm.setIntermediateCode(cb.create());

			RESULT = fm;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpoModulo",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // varSeqDeIds ::= TIDENTIFICADOR TCOMA varSeqDeIds 
            {
              VarSeqDeIds RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int seqleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int seqright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		VarSeqDeIds seq = (VarSeqDeIds)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 

		// COMPROBACIONES SEMANTICAS
  
			if ( seq.getIDs().contains(id.getLexema().toUpperCase()) ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". Identificador " + id.getLexema() + " duplicado");

        	seq.addID(id.getLexema().toUpperCase());
        	
        	RESULT = seq;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("varSeqDeIds",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // varSeqDeIds ::= TIDENTIFICADOR 
            {
              VarSeqDeIds RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new VarSeqDeIds(id.getLexema().toUpperCase() , id.getLine()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("varSeqDeIds",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // tipoPrimitivo ::= TBOOLEAN 
            {
              Expresion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Expresion(new TypeBoolean(scopeManager.getCurrentScope())); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipoPrimitivo",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // tipoPrimitivo ::= TINTEGER 
            {
              Expresion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Expresion(new TypeInteger(scopeManager.getCurrentScope())); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipoPrimitivo",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // expresion ::= error 
            {
              Expresion RESULT =null;
		 semanticErrorManager.semanticFatalError("Error en expresion"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // expresion ::= TIDENTIFICADOR TPARI sentCallParams TPARD 
            {
              Expresion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		SentCallParams params = (SentCallParams)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		

		// COMPROBACIONES SEMANTICAS

			SymbolIF symbol = scopeManager.searchSymbol(id.getLexema().toUpperCase());
        	
			if ( symbol == null ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". Funcion " + id.getLexema().toUpperCase() + " no definida");

			if ( ! (symbol.getType() instanceof TypeFunction) ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". El simbolo " + id.getLexema().toUpperCase() + " no es una funcion" );

			if ( params.getNumParams() != ((TypeFunction) symbol.getType()).getNumParams() ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". El n�mero de parametros de la funcion " + id.getLexema().toUpperCase() + " no coincide con los de la llamada");

			if ( params.compareTo(((TypeFunction) symbol.getType()).getParameters()) != null ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". El tipo del parametro " + params.compareTo(((TypeFunction) symbol.getType()).getParameters()).getType().getName() + " no coincide con el esperado");
	
			for ( Map.Entry<String, String> call: calls.entrySet() )
			{
				if ( call.getKey().equals(id.getLexema().toUpperCase()) && call.getValue().equals(scopeManager.getCurrentScope().getName()) ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". Recursividad indirecta no soportada");
			}

			if ( scopeManager.getCurrentScope().getLevel() != 0 && !scopeManager.getCurrentScope().getName().equals(id.getLexema().toUpperCase()) ) calls.put(scopeManager.getCurrentScope().getName(), id.getLexema().toUpperCase());
		
		// CODIGO INTERMEDIO

			Expresion exp = new Expresion(((TypeFunction) symbol.getType()).getReturnType());

			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
			TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());

			TemporalIF rTemp = tf.create();
			LabelIF labelProc = new Label("L_" + symbol.getScope().getName() + "_" + id.getLexema().toUpperCase(), symbol.getType());

			cb.addQuadruple("ENTER", labelProc);
			cb.addQuadruples(params.getIntermediateCode());
			cb.addQuadruple("CALL", labelProc);		
			cb.addQuadruple("RETURNVALUE", rTemp);

			exp.setTemporal(rTemp);
			exp.setIntermediateCode(cb.create());

			RESULT = exp;			
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // expresion ::= TIDENTIFICADOR TPUNTO TIDENTIFICADOR 
            {
              Expresion RESULT =null;
		int id1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id1 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

		// COMPROBACIONES SEMANTICAS

			SymbolIF symbol = scopeManager.searchSymbol(id1.getLexema().toUpperCase());
			
			if ( symbol == null ) semanticErrorManager.semanticFatalError("Linea " + id1.getLine() + ". Simbolo " + id1.getLexema().toUpperCase() + " no definido");
			
			if ( ! (symbol.getType() instanceof TypeRecord) ) semanticErrorManager.semanticFatalError("Linea " + id1.getLine() + ". El simbolo " + id1.getLexema().toUpperCase() + " no es un registro");
			
			if ( ! ((TypeRecord) symbol.getType()).containsField(id2.getLexema().toUpperCase()) ) semanticErrorManager.semanticFatalError("Linea " + id1.getLine() + ". Campo " + id2.getLexema().toUpperCase() + " no definido en el registro " + id1.getLexema().toUpperCase());

		// CODIGO INTERMEDIO

			Expresion e = new Expresion(((TypeRecord) symbol.getType()).getField(id2.getLexema().toUpperCase()).getType());

			TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
			
			TemporalIF temp = tf.create();
			TemporalIF temp1 = tf.create();
			TemporalIF temp2 = tf.create();
			TemporalIF temp3 = tf.create();

			int position = ((TypeRecord) symbol.getType()).getField(id2.getLexema()).getPosition();

			Variable var = new Variable(id1.getLexema().toUpperCase(), symbol.getScope());

			// Direccion base
			cb.addQuadruple("MVA", temp1, var);		

			// Desplazamiento
			cb.addQuadruple("MV", temp2, position);

			// Resta
			cb.addQuadruple("SUB", temp3, temp1, temp2);
			
			cb.addQuadruple("MVP", temp, temp3);

			e.setTemporal(temp);
			e.setIntermediateCode(cb.create());
			
			RESULT = e;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // expresion ::= TIDENTIFICADOR 
            {
              Expresion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

		// COMPROBACIONES SEMANTICAS

			SymbolIF symbol = scopeManager.searchSymbol(id.getLexema().toUpperCase());
			
			if ( symbol == null ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". Simbolo " + id.getLexema().toUpperCase() + " no definido");

			if ( symbol.getType() instanceof TypeProcedure && (!(symbol.getType() instanceof TypeFunction)) ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". " + id.getLexema() + " es un procedimiento");

			if ( symbol.getType() instanceof TypeFunction && ((TypeFunction) symbol.getType()).getNumParams() > 0 ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". El n�mero de par�metros de " + id.getLexema().toUpperCase() + " no coincide con el de la llamada");

		// CODIGO INTERMEDIO

			Expresion e = new Expresion(symbol.getType());

			TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
			
			TemporalIF temp = tf.create();

			if ( symbol instanceof SymbolConstant ) 
			{
				Value val = new Value(Integer.parseInt(((SymbolConstant) symbol).getValue()));
				cb.addQuadruple("MV", temp, val);
			}
			else if ( symbol instanceof SymbolVariable || symbol instanceof SymbolParameter )
			{
				Variable var = new Variable(id.getLexema().toUpperCase(), symbol.getScope());
				cb.addQuadruple("MVP", temp, var);
			}
			else
			{
				for ( Map.Entry<String, String> call: calls.entrySet() )
				{
					if ( call.getKey().equals(id.getLexema().toUpperCase()) && call.getValue().equals(scopeManager.getCurrentScope().getName()) ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". Recursividad indirecta no soportada");
				}

				if ( scopeManager.getCurrentScope().getLevel() != 0 && !scopeManager.getCurrentScope().getName().equals(id.getLexema().toUpperCase()) ) calls.put(scopeManager.getCurrentScope().getName(), id.getLexema().toUpperCase());
			}

			e.setTemporal(temp);
			e.setIntermediateCode(cb.create());
			
			RESULT = e;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // expresion ::= TLFALSE 
            {
              Expresion RESULT =null;
		int boolleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int boolright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token bool = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
			Expresion e = new Expresion(new TypeBoolean(scopeManager.getCurrentScope()));

		// CODIGO INTERMEDIO
				
			TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
			
			TemporalIF temp = tf.create();

			Value val = new Value(0);
			cb.addQuadruple("MV", temp, val);

			e.setTemporal(temp);
			e.setIntermediateCode(cb.create());

			RESULT = e;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // expresion ::= TLTRUE 
            {
              Expresion RESULT =null;
		int boolleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int boolright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token bool = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
			Expresion e = new Expresion(new TypeBoolean(scopeManager.getCurrentScope()));

		// CODIGO INTERMEDIO
				
			TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
			
			TemporalIF temp = tf.create();

			Value val = new Value(1);
			cb.addQuadruple("MV", temp, val);

			e.setTemporal(temp);
			e.setIntermediateCode(cb.create());

			RESULT = e;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // expresion ::= TLINT 
            {
              Expresion RESULT =null;
		int numleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int numright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token num = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
			Expresion e = new Expresion(new TypeInteger(scopeManager.getCurrentScope()));

		// CODIGO INTERMEDIO
				
			TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
			
			TemporalIF temp = tf.create();
			Value val = new Value(num.getLexema());

			cb.addQuadruple("MV", temp, val);

			e.setTemporal(temp);
			e.setIntermediateCode(cb.create());

			RESULT = e;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // expresion ::= expresion TDISTINTO expresion 
            {
              Expresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion e1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tdright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token td = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

		// COMPROBACIONES SEMANTICAS

        	if ( ! ((e1.getType() instanceof TypeInteger) && (e2.getType() instanceof TypeInteger)) ) semanticErrorManager.semanticFatalError("Linea " + td.getLine() + ". Operador <> entre tipos incompatibles " + e1.getType().getName() + ", " + e2.getType().getName());

			Expresion expr = new Expresion(new TypeBoolean(scopeManager.getCurrentScope()));

		// CODIGO INTERMEDIO
			
			TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
			
			TemporalIF temp = tf.create();
			TemporalIF e1Temp = e1.getTemporal();
			TemporalIF e2Temp = e2.getTemporal();

			cb.addQuadruples(e1.getIntermediateCode());
			cb.addQuadruples(e2.getIntermediateCode());
			cb.addQuadruple("NEQ", temp, e1Temp, e2Temp);

			expr.setTemporal(temp);
			expr.setIntermediateCode(cb.create());

			RESULT = expr;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // expresion ::= expresion TMENOR expresion 
            {
              Expresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion e1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tmleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tmright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token tm = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

		// COMPROBACIONES SEMANTICAS

        	if ( ! ((e1.getType() instanceof TypeInteger) && (e2.getType() instanceof TypeInteger)) ) semanticErrorManager.semanticFatalError("Linea " + tm.getLine() + ". Operador < entre tipos incompatibles " + e1.getType().getName() + ", " + e2.getType().getName());

			Expresion expr = new Expresion(new TypeBoolean(scopeManager.getCurrentScope()));

		// CODIGO INTERMEDIO
				
			TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
			
			TemporalIF temp = tf.create();
			TemporalIF e1Temp = e1.getTemporal();
			TemporalIF e2Temp = e2.getTemporal();

			cb.addQuadruples(e1.getIntermediateCode());
			cb.addQuadruples(e2.getIntermediateCode());
			cb.addQuadruple("LS", temp, e1Temp, e2Temp);

			expr.setTemporal(temp);
			expr.setIntermediateCode(cb.create());

			RESULT = expr;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // expresion ::= expresion TAND expresion 
            {
              Expresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion e1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int taleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int taright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token ta = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

		// COMPROBACIONES SEMANTICAS

        	if ( ! ((e1.getType() instanceof TypeBoolean) && (e2.getType() instanceof TypeBoolean)) ) semanticErrorManager.semanticFatalError("Linea " + ta.getLine() + ". Operador AND entre tipos incompatibles " + e1.getType().getName() + ", " + e2.getType().getName());

			Expresion expr = new Expresion(e1.getType());

		// CODIGO INTERMEDIO
				
			TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
			
			TemporalIF temp = tf.create();
			TemporalIF e1Temp = e1.getTemporal();
			TemporalIF e2Temp = e2.getTemporal();

			cb.addQuadruples(e1.getIntermediateCode());
			cb.addQuadruples(e2.getIntermediateCode());
			cb.addQuadruple("AND", temp, e1Temp, e2Temp);

			expr.setTemporal(temp);
			expr.setIntermediateCode(cb.create());

			RESULT = expr;     	
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // expresion ::= expresion TSUMA expresion 
            {
              Expresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion e1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token ts = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

		// COMPROBACIONES SEMANTICAS

        	if ( ! ((e1.getType() instanceof TypeInteger) && (e2.getType() instanceof TypeInteger)) ) semanticErrorManager.semanticFatalError("Linea " + ts.getLine() + ". Operador + entre tipos incompatibles " + e1.getType().getName() + ", " + e2.getType().getName());

			Expresion expr = new Expresion(e1.getType());

		// CODIGO INTERMEDIO
					
			TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
			
			TemporalIF temp = tf.create();
			TemporalIF e1Temp = e1.getTemporal();
			TemporalIF e2Temp = e2.getTemporal();

			cb.addQuadruples(e1.getIntermediateCode());
			cb.addQuadruples(e2.getIntermediateCode());
			cb.addQuadruple("ADD", temp, e1Temp, e2Temp);

			expr.setTemporal(temp);
			expr.setIntermediateCode(cb.create());

			RESULT = expr;     
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // expresion ::= expresion TDIVIDE expresion 
            {
              Expresion RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion e1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tdright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token td = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 

		// COMPROBACIONES SEMANTICAS
	
        	if ( ! ((e1.getType() instanceof TypeInteger) && (e2.getType() instanceof TypeInteger)) ) semanticErrorManager.semanticFatalError("Linea " + td.getLine() + ". Operador / entre tipos incompatibles " + e1.getType().getName() + ", " + e2.getType().getName());

			Expresion expr = new Expresion(e1.getType());

		// CODIGO INTERMEDIO
				
			TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
			
			TemporalIF temp = tf.create();
			TemporalIF e1Temp = e1.getTemporal();
			TemporalIF e2Temp = e2.getTemporal();

			cb.addQuadruples(e1.getIntermediateCode());
			cb.addQuadruples(e2.getIntermediateCode());
			cb.addQuadruple("DIV", temp, e1Temp, e2Temp);

			expr.setTemporal(temp);
			expr.setIntermediateCode(cb.create());

			RESULT = expr;     	
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // expresion ::= TPARI expresion TPARD 
            {
              Expresion RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion e = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = e; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // expresion ::= TNOT expresion 
            {
              Expresion RESULT =null;
		int tnleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tnright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token tn = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

		// COMPROBACIONES SEMANTICAS
	
        	if ( ! (e.getType() instanceof TypeBoolean) ) semanticErrorManager.semanticFatalError("Linea " + tn.getLine() + ". Negacion de tipo NO logico");

			Expresion expr = new Expresion(e.getType());

		// CODIGO INTERMEDIO
				
			TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
			
			TemporalIF temp = tf.create();
			TemporalIF eTemp = e.getTemporal();

			cb.addQuadruples(e.getIntermediateCode());
			cb.addQuadruple("NOT", temp, eTemp);

			expr.setTemporal(temp);
			expr.setIntermediateCode(cb.create());

			RESULT = expr;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // sentCallParams ::= error 
            {
              SentCallParams RESULT =null;
		 semanticErrorManager.semanticFatalError("Error en argumentos de sentencia de llamada"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentCallParams",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // sentCallParams ::= 
            {
              SentCallParams RESULT =null;
		 RESULT = new SentCallParams(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentCallParams",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // sentCallParams ::= TIDENTIFICADOR TPUNTO TIDENTIFICADOR TCOMA sentCallParams 
            {
              SentCallParams RESULT =null;
		int id1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id1 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentCallParams params = (SentCallParams)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

		// COMPROBACIONES SEMANTICAS

			SymbolIF symbol = scopeManager.searchSymbol(id1.getLexema().toUpperCase());

			if ( symbol == null ) semanticErrorManager.semanticFatalError("Linea " + id1.getLine() + ". Simbolo " + id1.getLexema().toUpperCase() + " no definido");		

			if ( ! (symbol.getType() instanceof TypeRecord) ) semanticErrorManager.semanticFatalError("Linea " + id1.getLine() + ". El simbolo " + id1.getLexema().toUpperCase() + " no es un registro");
			
			if ( ! ((TypeRecord) symbol.getType()).containsField(id2.getLexema().toUpperCase()) ) semanticErrorManager.semanticFatalError("Linea " + id1.getLine() + ". Simbolo " + id2.getLexema().toUpperCase() + " no definido en el registro " + id1.getLexema().toUpperCase());

			RegCampo field = ((TypeRecord) symbol.getType()).getField(id2.getLexema());

		// CODIGO INTERMEDIO

			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
			TemporalFactoryIF tf = new TemporalFactory(scopeManager.getCurrentScope());
			
			cb.addQuadruples(params.getIntermediateCode());

			TemporalIF temp1 = tf.create();
			TemporalIF temp2 = tf.create();
			TemporalIF temp3 = tf.create();

			int position = ((TypeRecord) symbol.getType()).getField(id2.getLexema()).getPosition();

			Variable var = new Variable(id1.getLexema().toUpperCase(), symbol.getScope());

			// Direccion base
			cb.addQuadruple("MVA", temp1, var);

			// Desplazamiento
			cb.addQuadruple("MV", temp2, position);

			// Resta
			cb.addQuadruple("SUB", temp3, temp1, temp2);

			cb.addQuadruple("PARAM", temp3);

			SymbolParameter param = new SymbolParameter(symbol.getScope(), symbol.getName() + "." + field.getName(), field.getType());

			params.addParameter(param);
			params.setIntermediateCode(cb.create());

			RESULT = params;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentCallParams",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // sentCallParams ::= TIDENTIFICADOR TPUNTO TIDENTIFICADOR 
            {
              SentCallParams RESULT =null;
		int id1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id1 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

		// COMPROBACIONES SEMANTICAS

			SymbolIF symbol = scopeManager.searchSymbol(id1.getLexema().toUpperCase());

			if ( symbol == null ) semanticErrorManager.semanticFatalError("Linea " + id1.getLine() + ". Simbolo " + id1.getLexema().toUpperCase() + " no definido");
			
			if ( ! (symbol.getType() instanceof TypeRecord) ) semanticErrorManager.semanticFatalError("Linea " + id1.getLine() + ". El simbolo " + id1.getLexema().toUpperCase() + " no es un registro");

			if ( ! ((TypeRecord) symbol.getType()).containsField(id2.getLexema().toUpperCase()) ) semanticErrorManager.semanticFatalError("Linea " + id1.getLine() + ". Simbolo " + id2.getLexema().toUpperCase() + " no definido en el registro " + id1.getLexema().toUpperCase());

		// CODIGO INTERMEDIO

			RegCampo field = ((TypeRecord) symbol.getType()).getField(id2.getLexema());	

			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
			TemporalFactoryIF tf = new TemporalFactory(scopeManager.getCurrentScope());
			
			TemporalIF temp1 = tf.create();
			TemporalIF temp2 = tf.create();
			TemporalIF temp3 = tf.create();
			Variable var = new Variable(id1.getLexema().toUpperCase(), symbol.getScope());

			int position = ((TypeRecord) symbol.getType()).getField(id2.getLexema()).getPosition();			

			// Direccion base
			cb.addQuadruple("MVA", temp1, var);

			// Desplazamiento
			cb.addQuadruple("MV", temp2, position);

			// Resta
			cb.addQuadruple("SUB", temp3, temp1, temp2);

			cb.addQuadruple("PARAM", temp3);

			SymbolParameter param = new SymbolParameter(symbol.getScope(), symbol.getName() + "." + field.getName(), field.getType());

			SentCallParams params = new SentCallParams(param);

			params.setIntermediateCode(cb.create());

			RESULT = params;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentCallParams",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // sentCallParams ::= TIDENTIFICADOR TCOMA sentCallParams 
            {
              SentCallParams RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentCallParams params = (SentCallParams)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

		// COMPROBACIONES SEMANTICAS

			SymbolIF param = scopeManager.searchSymbol(id.getLexema().toUpperCase());

			if ( param == null ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". Simbolo " + id.getLexema().toUpperCase() + " no definido");

			if ( param instanceof SymbolConstant || param instanceof SymbolProcedure ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". El simbolo " + id.getLexema().toUpperCase() + " no se puede pasar por referencia");
						
			params.addParameter(new SymbolParameter(param.getScope(), param.getName(), param.getType()));

		// CODIGO INTERMEDIO

			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
			TemporalFactoryIF tf = new TemporalFactory(scopeManager.getCurrentScope());
			
			TemporalIF temp = tf.create();
			Variable var = new Variable(param.getName(), param.getScope());

			cb.addQuadruples(params.getIntermediateCode());
			cb.addQuadruple("MVA", temp, var);
			cb.addQuadruple("PARAM", temp);

			params.setIntermediateCode(cb.create());

			RESULT = params;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentCallParams",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // sentCallParams ::= TIDENTIFICADOR 
            {
              SentCallParams RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

		// COMPROBACIONES SEMANTICAS

			SymbolIF param = scopeManager.searchSymbol(id.getLexema().toUpperCase());

			if ( param == null ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". Simbolo " + id.getLexema().toUpperCase() + " no definido");

			if ( param instanceof SymbolConstant || param instanceof SymbolProcedure ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". El simbolo " + id.getLexema().toUpperCase() + " no se puede pasar por referencia");

		// CODIGO INTERMEDIO

			SentCallParams params = new SentCallParams(new SymbolParameter(param.getScope(), param.getName(), param.getType()));

			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
			TemporalFactoryIF tf = new TemporalFactory(scopeManager.getCurrentScope());
	
			TemporalIF temp = tf.create();
			Variable var = new Variable(param.getName(), param.getScope());
			
			cb.addQuadruple("MVA", temp, var);
			cb.addQuadruple("PARAM", temp);

			params.setIntermediateCode(cb.create());	
		
			RESULT = params;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentCallParams",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // sentCall ::= TIDENTIFICADOR 
            {
              Sent RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

		// COMPROBACIONES SEMANTICAS

			SymbolIF symbol = scopeManager.searchSymbol(id.getLexema().toUpperCase());
        	
			if ( symbol == null ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". Simbolo " + id.getLexema().toUpperCase() + " no definido");
			
			if ( symbol.getType() instanceof TypeFunction ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". " + id.getLexema().toUpperCase() + " no es un procedimiento");

			if ( symbol.getType() instanceof TypeProcedure && ((TypeProcedure) symbol.getType()).getNumParams() > 0 ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". El numero de parametros del procedimiento " + id.getLexema().toUpperCase() + " no coincide con los de la llamada");

			for ( Map.Entry<String, String> call: calls.entrySet() )
			{
				if ( call.getKey().equals(id.getLexema().toUpperCase()) && call.getValue().equals(scopeManager.getCurrentScope().getName()) ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". Recursividad indirecta no soportada");
			}

			if ( scopeManager.getCurrentScope().getLevel() != 0 && !scopeManager.getCurrentScope().getName().equals(id.getLexema().toUpperCase()) ) calls.put(scopeManager.getCurrentScope().getName(), id.getLexema().toUpperCase());

		// CODIGO INTERMEDIO

			Sent sent = new Sent();

			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());

			LabelIF labelProc = new Label("L_" + symbol.getScope().getName() + "_" + id.getLexema().toUpperCase(), symbol.getType());

			cb.addQuadruple("ENTER", labelProc);
			cb.addQuadruple("CALL", labelProc);

			sent.setIntermediateCode(cb.create());
			
			RESULT = sent;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentCall",27, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // sentCall ::= TIDENTIFICADOR TPARI sentCallParams TPARD 
            {
              Sent RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int paramsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int paramsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		SentCallParams params = (SentCallParams)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		

		// COMPROBACIONES SEMANTICAS

			SymbolIF symbol = scopeManager.searchSymbol(id.getLexema().toUpperCase());
        	
			if ( symbol == null ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". Procedimiento " + id.getLexema().toUpperCase() + " no definido");
			
			if ( symbol.getType() instanceof TypeFunction ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". " + id.getLexema().toUpperCase() + " no es un procedimiento");
 
			if ( params.getNumParams() != ((TypeProcedure) symbol.getType()).getNumParams() ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". El numero de parametros del procedimiento " + id.getLexema().toUpperCase() + " no coincide con los de la llamada");
	
			if ( params.compareTo(((TypeProcedure) symbol.getType()).getParameters()) != null ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". El tipo del parametro " + params.compareTo(((TypeProcedure) symbol.getType()).getParameters()).getType().getName() + " no coincide con el esperado");

			for ( Map.Entry<String, String> call: calls.entrySet() )
			{
				if ( call.getKey().equals(id.getLexema().toUpperCase()) && call.getValue().equals(scopeManager.getCurrentScope().getName()) ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". Recursividad indirecta no soportada");
			}

			if ( scopeManager.getCurrentScope().getLevel() != 0 && !scopeManager.getCurrentScope().getName().equals(id.getLexema().toUpperCase()) ) calls.put(scopeManager.getCurrentScope().getName(), id.getLexema().toUpperCase());

		// CODIGO INTERMEDIO

			Sent sent = new Sent();

			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());

			LabelIF labelProc = new Label("L_" + symbol.getScope().getName() + "_" + id.getLexema().toUpperCase(), symbol.getType());

			cb.addQuadruple("ENTER", labelProc);
			cb.addQuadruples(params.getIntermediateCode());
			cb.addQuadruple("CALL", labelProc);

			sent.setIntermediateCode(cb.create());

			RESULT = sent;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentCall",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // sentReturn ::= TRETURN expresion 
            {
              Sent RESULT =null;
		int tRetleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tRetright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token tRet = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

		// COMPROBACIONES SEMANTICAS
	
			SymbolIF symbol = scopeManager.getParentScope().getSymbolTable().getSymbol(scopeManager.getCurrentScope().getName());

			if ( ! (symbol instanceof SymbolFunction) ) semanticErrorManager.semanticFatalError("Linea " + tRet.getLine() + ". Sentencia RETURN dentro del procedimiento " + scopeManager.getCurrentScope().getName());
		 			
			if ( ((TypeFunction) symbol.getType()).getReturnType().getName() != e.getType().getName() ) semanticErrorManager.semanticFatalError("Linea " + tRet.getLine() + ". El tipo de retorno " + e.getType().getName() + " no coincide con el de la funcion " + scopeManager.getCurrentScope().getName() + " " + ((TypeFunction) symbol.getType()).getReturnType().getName());

		// CODIGO INTERMEDIO

			Sent sent = new Sent(e.getType());

			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(symbol.getScope());

			TemporalIF temp = e.getTemporal();
			LabelIF labelRet = lf.create("FIN_" + scopeManager.getParentScope().getName() + "_" + scopeManager.getCurrentScope().getName());

			cb.addQuadruples(e.getIntermediateCode());
			cb.addQuadruple("RET", labelRet, temp);

			sent.setTemporal(temp);
			sent.setIntermediateCode(cb.create());

        	RESULT = sent;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentReturn",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // sentES ::= TWRITELN 
            {
              Sent RESULT =null;
		

		// CODIGO INTERMEDIO

			Sent sent = new Sent();

			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());

			cb.addQuadruple("WRITELN");
			
			sent.setIntermediateCode(cb.create());

			RESULT = sent;			
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentES",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // sentES ::= TWRITEINT TPARI expresion TPARD 
            {
              Sent RESULT =null;
		int tesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int tesright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token tes = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion e = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 

		// COMPROBACIONES SEMANTICAS

			if ( ! (e.getType() instanceof TypeInteger) ) semanticErrorManager.semanticFatalError("Linea " + tes.getLine() + ". El parametro de WRITEINT no es de tipo INTEGER");

		// CODIGO INTERMEDIO

			Sent sent = new Sent();

			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());

			TemporalIF temp = e.getTemporal();
			
			cb.addQuadruples(e.getIntermediateCode());
			cb.addQuadruple("WRITEINT", temp);
			
			sent.setIntermediateCode(cb.create());

			RESULT = sent; 
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentES",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // sentES ::= TWRITESTRING TPARI TLSTRING TPARD 
            {
              Sent RESULT =null;
		int stleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int stright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token st = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 

		// CODIGO INTERMEDIO

			Sent sent = new Sent();

			TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());

			LabelIF labelES = lf.create();
			TemporalIF temp = tf.create();			

			cb.addQuadruple("WRITESTR", temp, labelES);
			
			sent.setIntermediateCode(cb.create());

			stringList.add(new Quadruple("STRINGDATA", new Label(st.getLexema()), labelES));

			RESULT = sent;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentES",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // sentElse ::= 
            {
              Sentencias RESULT =null;
		 RESULT = new Sentencias(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentElse",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // sentElse ::= TELSE sentencias 
            {
              Sentencias RESULT =null;
		int sentencesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentencesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencias sentences = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = sentences; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentElse",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // sentIf ::= TIF expresion TTHEN sentencias sentElse 
            {
              Sent RESULT =null;
		int tifleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int tifright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token tif = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Expresion e = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int sentencesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sentencesright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Sentencias sentences = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sentEleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentEright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencias sentE = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 

		// COMPROBACIONES SEMANTICAS

			if ( ! (e.getType() instanceof TypeBoolean) ) semanticErrorManager.semanticFatalError("Linea " + tif.getLine() + " .La condicion de la sentencia IF no es de tipo BOOLEAN");

			Sent sent = new Sent();

			if ( sentences.isReturnContained() || sentE.isReturnContained() ) 
			{
				if ( !(sentences.isReturnContained() && sentE.isReturnContained()) ) sent.setBalanced(false);

				if ( sentences.isReturnContained() ) sent.setReturnType(sentences.getReturnType());
				else sent.setReturnType(sentE.getReturnType());
			}

		// CODIGO INTERMEDIO

			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
			
			LabelIF labelEndIf = lf.create();
			LabelIF labelElse = lf.create();		
			TemporalIF temp = e.getTemporal();

			cb.addQuadruples(e.getIntermediateCode());
			cb.addQuadruple("BRF", temp, labelElse);
			cb.addQuadruples(sentences.getIntermediateCode());
			cb.addQuadruple("BR", labelEndIf);
			
			cb.addQuadruple("INL", labelElse);
			cb.addQuadruples(sentE.getIntermediateCode());
			cb.addQuadruple("INL", labelEndIf);
			
			sent.setIntermediateCode(cb.create());
			
			RESULT = sent; 
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentIf",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // sentWhile ::= TWHILE expresion TDO sentencias 
            {
              Sent RESULT =null;
		int twlleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int twlright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token twl = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion e = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sentencesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentencesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencias sentences = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 

		// COMPROBACIONES SEMANTICAS

			if ( ! (e.getType() instanceof TypeBoolean) ) semanticErrorManager.semanticFatalError("Linea " + twl.getLine() + " .La condicion de la sentencia WHILE no es de tipo BOOLEAN");

			Sent sent = new Sent();

			if ( sentences.isReturnContained() ) 
			{
				if ( ! sentences.isBalanced() ) sent.setBalanced(false);

				sent.setReturnType(sentences.getReturnType());
			}

		// CODIGO INTERMEDIO

			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	
			LabelIF labelEndWhile = lf.create();
			LabelIF labelWhile = lf.create();		
			TemporalIF temp = e.getTemporal();

			cb.addQuadruple("INL", labelEndWhile);
			cb.addQuadruples(e.getIntermediateCode());
			cb.addQuadruple("BRF", temp, labelWhile);
			cb.addQuadruples(sentences.getIntermediateCode());
			cb.addQuadruple("BR", labelEndWhile);
			cb.addQuadruple("INL", labelWhile);
			
			sent.setIntermediateCode(cb.create());

			RESULT = sent;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentWhile",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // sentAsign ::= TIDENTIFICADOR TPUNTO TIDENTIFICADOR TASSIGN expresion 
            {
              Sent RESULT =null;
		int id1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id1 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

		// COMPROBACIONES SEMANTICAS

        	SymbolIF symbol = scopeManager.searchSymbol(id1.getLexema().toUpperCase());
			
 			if ( symbol == null ) semanticErrorManager.semanticFatalError("Linea " + id1.getLine() + ". Asignacion a simbolo " + id1.getLexema().toUpperCase() + " no definido");
     	
			if ( ! (symbol instanceof SymbolVariable) && ! (symbol instanceof SymbolParameter) ) semanticErrorManager.semanticFatalError("Linea " + id1.getLine() + ". Asignacion a simbolo no variable " + id1.getLexema().toUpperCase());
 
			if ( ! (symbol.getType() instanceof TypeRecord) ) semanticErrorManager.semanticFatalError("Linea " + id1.getLine() + ". El simbolo " + id1.getLexema().toUpperCase() + " no es un registro");
			
			if ( ! ((TypeRecord) symbol.getType()).containsField(id2.getLexema().toUpperCase()) ) semanticErrorManager.semanticFatalError("Linea " + id1.getLine() + ". El registro " + id1.getLexema().toUpperCase() + " no contiene el campo " + id2.getLexema().toUpperCase());	
 
        	if ( ! ((TypeRecord) symbol.getType()).getField(id2.getLexema().toUpperCase()).getType().getName().equals(e.getType().getName()) ) semanticErrorManager.semanticFatalError("Linea " + id1.getLine() + ". Asignacion a campo de tipo " + e.getType().getName() + " a tipo " + ((TypeRecord) symbol.getType()).getField(id2.getLexema().toUpperCase()).getType().getName());

		// CODIGO INTERMEDIO

			Sent sentAsig = new Sent();
			
			int position = ((TypeRecord) symbol.getType()).getField(id2.getLexema()).getPosition();

			TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());

			TemporalIF temp = tf.create();
			TemporalIF temp2 = tf.create();
			TemporalIF temp3 = tf.create();
			TemporalIF eTemp = e.getTemporal();
			Variable var = new Variable(id1.getLexema().toUpperCase(), symbol.getScope());

			cb.addQuadruples(e.getIntermediateCode());

			// Direccion base
			cb.addQuadruple("MVA", temp, var);		

			// Desplazamiento
			cb.addQuadruple("MV", temp2, position);

			// Resta
			cb.addQuadruple("SUB", temp3, temp, temp2);

			cb.addQuadruple("STP", temp3, eTemp);

			sentAsig.setTemporal(eTemp);
			sentAsig.setIntermediateCode(cb.create());

			RESULT = sentAsig;	   		
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentAsign",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // sentAsign ::= TIDENTIFICADOR TASSIGN expresion 
            {
              Sent RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

		// COMPROBACIONES SEMANTICAS

        	SymbolIF symbol = scopeManager.searchSymbol(id.getLexema().toUpperCase());

 			if ( symbol == null ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". Asignacion a simbolo " + id.getLexema().toUpperCase() + " no definido");
 			
			if ( ! (symbol instanceof SymbolVariable) && ! (symbol instanceof SymbolParameter) ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". Asignacion a simbolo no variable " + id.getLexema().toUpperCase());
 
			if ( symbol.getType() instanceof TypeRecord ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". Asignacion a registro " + id.getLexema().toUpperCase());
 
        	if ( ! symbol.getType().getName().equals(e.getType().getName()) ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". Asignacion de tipo " + e.getType().getName() + " a tipo " + symbol.getType().getName());

		// CODIGO INTERMEDIO

			Sent sentAsig = new Sent();

			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
			TemporalFactory tf = new TemporalFactory(scopeManager.getCurrentScope());

			TemporalIF temp = tf.create();
			TemporalIF eTemp = e.getTemporal();
			Variable var = new Variable(id.getLexema().toUpperCase(), symbol.getScope());

			cb.addQuadruples(e.getIntermediateCode());
			cb.addQuadruple("MVA", temp, var);
			cb.addQuadruple("STP", temp, eTemp);

			sentAsig.setTemporal(eTemp);
			sentAsig.setIntermediateCode(cb.create());

			RESULT = sentAsig;		
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentAsign",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // sent ::= error 
            {
              Sent RESULT =null;
		 semanticErrorManager.semanticFatalError("Error en sentencia"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sent",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // sent ::= sentCall 
            {
              Sent RESULT =null;
		int sentCleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentCright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sent sentC = (Sent)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = sentC; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sent",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // sent ::= sentWhile TEND 
            {
              Sent RESULT =null;
		int sentWleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sentWright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Sent sentW = (Sent)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = sentW; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sent",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // sent ::= sentIf TEND 
            {
              Sent RESULT =null;
		int sentIleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sentIright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Sent sentI = (Sent)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = sentI; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sent",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // sent ::= sentReturn 
            {
              Sent RESULT =null;
		int sentRleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentRright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sent sentR = (Sent)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = sentR; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sent",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // sent ::= sentES 
            {
              Sent RESULT =null;
		int sentEleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentEright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sent sentE = (Sent)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = sentE; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sent",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // sent ::= sentAsign 
            {
              Sent RESULT =null;
		int sentAsigleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentAsigright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sent sentAsig = (Sent)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = sentAsig; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sent",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // sentencias ::= error 
            {
              Sentencias RESULT =null;
		 semanticErrorManager.semanticFatalError("Error en sentencias"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // sentencias ::= 
            {
              Sentencias RESULT =null;
		 RESULT = new Sentencias(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // sentencias ::= sent ntPtoComa sentencias 
            {
              Sentencias RESULT =null;
		int sentenceleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sentenceright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Sent sentence = (Sent)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sentencesleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentencesright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencias sentences = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			sentences.addSentence(sentence);
			
		// CODIGO INTERMEDIO
			
			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());

			cb.addQuadruples(sentence.getIntermediateCode());
			cb.addQuadruples(sentences.getIntermediateCode());

			sentences.setIntermediateCode(cb.create());
        	
			RESULT = sentences;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // subReturn ::= error 
            {
              Sent RESULT =null;
		 semanticErrorManager.semanticFatalError("Tipo de retorno de funcion no especificado"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subReturn",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // subReturn ::= 
            {
              Sent RESULT =null;
		 RESULT = new Sent(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subReturn",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // subReturn ::= TDOSPTS tipoPrimitivo 
            {
              Sent RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion t = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Sent(t.getType()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subReturn",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // subPar ::= error 
            {
              VarSeqDeIds RESULT =null;
		 semanticErrorManager.semanticFatalError("Definicion de subrutina. Error en el formato de parametros"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subPar",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // subPar ::= TVAR varSeqDeIds TDOSPTS varTipo 
            {
              VarSeqDeIds RESULT =null;
		int seqleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int seqright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		VarSeqDeIds seq = (VarSeqDeIds)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion t = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new VarSeqDeIds(t.getType(), seq.getIDs(), seq.getLine()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subPar",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // subParamsCuerpo ::= subPar 
            {
              Subrutina RESULT =null;
		int paramleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		VarSeqDeIds param = (VarSeqDeIds)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Subrutina(param); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subParamsCuerpo",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // subParamsCuerpo ::= subPar ntPtoComa subParamsCuerpo 
            {
              Subrutina RESULT =null;
		int paramleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int paramright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		VarSeqDeIds param = (VarSeqDeIds)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int cuerpoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cuerporight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Subrutina cuerpo = (Subrutina)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

		// COMPROBACIONES SEMANTICAS

			if ( cuerpo.containsParam(param) != null ) semanticErrorManager.semanticFatalError("Linea " + param.getLine() + ". Declaracion de parametros en subrutina. Parametro " + cuerpo.containsParam(param) + " duplicado");
 
        	cuerpo.addParameter(param);
        	
        	RESULT = cuerpo;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subParamsCuerpo",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // subParams ::= 
            {
              Subrutina RESULT =null;
		 RESULT = new Subrutina(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subParams",18, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // subParams ::= TPARI subParamsCuerpo TPARD 
            {
              Subrutina RESULT =null;
		int parsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int parsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Subrutina pars = (Subrutina)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = new Subrutina(pars.getParamSeq()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subParams",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // subParams ::= TPARI TPARD 
            {
              Subrutina RESULT =null;
		 RESULT = new Subrutina(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subParams",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // subDecl ::= error 
            {
              Subrutina RESULT =null;
		 semanticErrorManager.semanticFatalError("Se esperaba un identificador para la subrutina"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subDecl",17, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // subDecl ::= TIDENTIFICADOR subParams subReturn ntPtoComa 
            {
              Subrutina RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int sParamsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sParamsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Subrutina sParams = (Subrutina)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int subRetleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int subRetright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Sent subRet = (Sent)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
			

		// COMPROBACIONES SEMANTICAS

			ScopeIF scope = scopeManager.getCurrentScope();
			TypeTableIF typeTable = scope.getTypeTable();
			SymbolTableIF symbolTable = scope.getSymbolTable();

			if ( symbolTable.containsSymbol(id.getLexema().toUpperCase()) ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". Declaracion de subrutina. Simbolo " + id.getLexema().toUpperCase() + " ya declarado");

    		ScopeIF newScope = scopeManager.openScope(id.getLexema().toUpperCase());
    		SymbolTableIF newSymbolTable = newScope.getSymbolTable();

			TypeProcedure typeSubroutine = new TypeProcedure(scope, id.getLexema().toUpperCase());
			SymbolIF symbolSubroutine = new SymbolProcedure(scope, id.getLexema().toUpperCase(), typeSubroutine);

    		if ( subRet.getReturnType() != null )
			{	
				typeSubroutine = new TypeFunction(scope, id.getLexema().toUpperCase(), subRet.getReturnType());
				symbolSubroutine = new SymbolFunction(scope, id.getLexema().toUpperCase(), typeSubroutine);
			}
			
			typeSubroutine.addParamSeq(sParams.getParamSeq(), newScope);

			int position = 0;

			for ( SymbolParameter param: ((TypeProcedure) typeSubroutine).getParameters() )
			{
				param.setPosition(position);

				position ++;

				newSymbolTable.addSymbol(param);
			}
 
			typeTable.addType(id.getLexema().toUpperCase(), typeSubroutine);
			symbolTable.addSymbol(id.getLexema().toUpperCase(), symbolSubroutine);

		// CODIGO INTERMEDIO

			if ( nesting < newScope.getLevel() ) nesting = newScope.getLevel();
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subDecl",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // subs ::= 
            {
              Sentencias RESULT =null;
		 RESULT = new Sentencias(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subs",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // subs ::= subs TPROCEDURE subDecl cuerpoModulo 
            {
              Sentencias RESULT =null;
		int suleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int suright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Sentencias su = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int cmleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cmright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencias cm = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 

		// CODIGO INTERMEDIO

			IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());

			cb.addQuadruples(cm.getIntermediateCode());
			cb.addQuadruples(su.getIntermediateCode());

			cm.setIntermediateCode(cb.create());

			RESULT = cm; 
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subs",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // varTipo ::= TIDENTIFICADOR 
            {
              Expresion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

		// COMPROBACIONES SEMANTICAS
		
			if ( ! scopeManager.containsType(id.getLexema().toUpperCase()) ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". Tipo " + id.getLexema().toUpperCase() + " no declarado");

        	RESULT = new Expresion(scopeManager.searchType(id.getLexema().toUpperCase()));	
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("varTipo",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // varTipo ::= tipoPrimitivo 
            {
              Expresion RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion t = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Expresion(t.getType()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("varTipo",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // var ::= error 
            {
              Expresion RESULT =null;
		 semanticErrorManager.semanticFatalError("Declaracion de variable invalida"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("var",14, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // var ::= varSeqDeIds TDOSPTS varTipo ntPtoComa 
            {
              Expresion RESULT =null;
		int seqleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int seqright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		VarSeqDeIds seq = (VarSeqDeIds)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int dptleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int dptright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token dpt = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion t = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
			

		// COMPROBACIONES SEMANTICAS

        	SymbolTableIF symbolTable = scopeManager.getCurrentScope().getSymbolTable();
        	
        	for ( String id: seq.getIDs() )
        	{
        		if ( symbolTable.containsSymbol(id.toUpperCase()) ) semanticErrorManager.semanticFatalError("Linea " + dpt.getLine() + ". Declaracion de variable. Simbolo " + id + " ya declarado");
 
        		symbolTable.addSymbol(new SymbolVariable(scopeManager.getCurrentScope(), id.toUpperCase(), t.getType()));		
        	}
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("var",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // varsLista ::= var 
            {
              Expresion RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("varsLista",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // varsLista ::= var varsLista 
            {
              Expresion RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("varsLista",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // vars ::= 
            {
              Expresion RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("vars",12, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // vars ::= TVAR varsLista 
            {
              Expresion RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("vars",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // regCampo ::= error 
            {
              RegCampo RESULT =null;
		 semanticErrorManager.semanticFatalError("Error en declaracion de campos de registro en el ambito " + scopeManager.getCurrentScope().getName()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("regCampo",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // regCampo ::= TIDENTIFICADOR TDOSPTS TIDENTIFICADOR ntPtoComa 
            {
              RegCampo RESULT =null;
		int id1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id1 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 semanticErrorManager.semanticFatalError("Linea " + id1.getLine() + ". Asignacion a campo " + id1.getLexema().toUpperCase() + " de tipo no primitivo " + id2.getLexema().toUpperCase()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("regCampo",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // regCampo ::= TIDENTIFICADOR TDOSPTS tipoPrimitivo ntPtoComa 
            {
              RegCampo RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int typeleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int typeright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion type = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = new RegCampo(id.getLexema().toUpperCase(), type.getType(), id.getLine()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("regCampo",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // regCampos ::= regCampo 
            {
              Registro RESULT =null;
		int fieldleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fieldright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		RegCampo field = (RegCampo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Registro(field); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("regCampos",10, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // regCampos ::= regCampo regCampos 
            {
              Registro RESULT =null;
		int fieldleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int fieldright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		RegCampo field = (RegCampo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int fieldsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fieldsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Registro fields = (Registro)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		   

		// COMPROBACIONES SEMANTICAS
   
	        if ( fields.containsField(field.getName()) ) semanticErrorManager.semanticFatalError("Linea " + field.getLine() + ". Declaracion de campo de registro. Simbolo " + field.getName() + " ya declarado en el registro");
 
        	fields.addField(field);

        	RESULT = fields;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("regCampos",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // registro ::= error 
            {
              Registro RESULT =null;
		 semanticErrorManager.semanticFatalError("Declaracion de campos vacia"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("registro",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // registro ::= TRECORD regCampos TEND 
            {
              Registro RESULT =null;
		int fieldsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int fieldsright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Registro fields = (Registro)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
			fields.setPositions();
			RESULT = fields; 
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("registro",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // tipo ::= error 
            {
              Registro RESULT =null;
		 semanticErrorManager.semanticFatalError("Error en la zona de declaracion de tipos del ambito " + scopeManager.getCurrentScope().getName()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // tipo ::= TIDENTIFICADOR TIGUAL registro ntPtoComa 
            {
              Registro RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int recordleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int recordright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Registro record = (Registro)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		

		// COMPROBACIONES SEMANTICAS

			ScopeIF scope = scopeManager.getCurrentScope();
        	TypeTableIF typeTable = scope.getTypeTable();
        	
        	if ( scopeManager.containsType(id.getLexema().toUpperCase()) ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". Declaracion de registro. Simbolo " + id.getLexema().toUpperCase() + " ya declarado");
 	
        	typeTable.addType (new TypeRecord(scope, id.getLexema().toUpperCase(), record.getFields()));
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // tiposLista ::= tipo 
            {
              Registro RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tiposLista",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // tiposLista ::= tipo tiposLista 
            {
              Registro RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tiposLista",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // tipos ::= 
            {
              Registro RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipos",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // tipos ::= TTYPE tiposLista 
            {
              Registro RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipos",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // cteValor ::= TLINT 
            {
              Constante RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token val = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Constante(new TypeInteger(scopeManager.getCurrentScope()), val.getLexema()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cteValor",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // cteValor ::= TLFALSE 
            {
              Constante RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token val = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Constante(new TypeBoolean(scopeManager.getCurrentScope()), "0"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cteValor",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // cteValor ::= TLTRUE 
            {
              Constante RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token val = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Constante(new TypeBoolean(scopeManager.getCurrentScope()), "1"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cteValor",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // cte ::= error 
            {
              Constante RESULT =null;
		 semanticErrorManager.semanticFatalError("Error en la zona de declaracion de constantes del ambito " + scopeManager.getCurrentScope().getName()); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cte",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // cte ::= TIDENTIFICADOR TIGUAL cteValor ntPtoComa 
            {
              Constante RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Constante val = (Constante)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		

		// COMPROBACIONES SEMANTICAS

			ScopeIF scope = scopeManager.getCurrentScope();
        	SymbolTableIF symbolTable = scope.getSymbolTable();

        	if ( symbolTable.containsSymbol(id.getLexema().toUpperCase()) ) semanticErrorManager.semanticFatalError("Linea " + id.getLine() + ". Declaracion de constante. Simbolo " +  id.getLexema().toUpperCase() +  " ya declarado");
 
        	symbolTable.addSymbol(new SymbolConstant(scope, id.getLexema().toUpperCase(), val.getType(), val.getValue()));
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cte",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // ctesLista ::= cte 
            {
              Constante RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ctesLista",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // ctesLista ::= cte ctesLista 
            {
              Constante RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ctesLista",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // ctes ::= 
            {
              Constante RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ctes",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // ctes ::= TCONST ctesLista 
            {
              Constante RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ctes",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // axiom ::= TMODULE error 
            {
              Axiom RESULT =null;
		 semanticErrorManager.semanticFatalError("Se esperaba un identificador para el modulo"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiom",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // axiom ::= TMODULE TIDENTIFICADOR NT$1 ntPtoComa cuerpoModulo 
            {
              Axiom RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Axiom) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int cmleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cmright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencias cm = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
			Axiom axiom = new AxiomImpl();
			axiom.setIntermediateCode(cm.getIntermediateCode());

			RESULT = axiom;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiom",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // NT$1 ::= 
            {
              Axiom RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

			ScopeIF scope = scopeManager.openScope(id.getLexema().toUpperCase());
        	TypeTableIF typeTable = scope.getTypeTable();        	        	

        	typeTable.addType(new TypeInteger(scope));
        	typeTable.addType(new TypeBoolean(scope));
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$1",39, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // program ::= NT$0 axiom 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int axleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int axright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Axiom ax = (Axiom)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		

		// CODIGO INTERMEDIO

			List<ScopeIF> scopes = scopeManager.getAllScopes();

			for ( ScopeIF scope: scopes )
			{
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);

				if ( scope.getLevel() == 0 )
				{
					Value nest = new Value(nesting);
 
					cb.addQuadruple("DISPLAY", nest);
					cb.addQuadruple("DATA");
	
					int sizeRA = scope.getTemporalTable().getSize() + 4;

					for ( SymbolIF symbol: scope.getSymbolTable().getSymbols() )
					{
						if ( symbol instanceof SymbolVariable ) 
						{
							int address = ((SymbolVariable) symbol).getAddress();				
							
							if ( scope.getSymbolTable().getSymbol(symbol.getName()).getType() instanceof TypeRecord )
							{				
								for ( RegCampo campo: ((TypeRecord) symbol.getType()).getFields() )
								{
									Label var = new Label(symbol.getName() + "_" + campo.getName());
									cb.addQuadruple("GLOBALVARIABLE", var, 0);
									sizeRA ++;
								}
							}
							else
							{
								Label var = new Label(symbol.getName());
								cb.addQuadruple("GLOBALVARIABLE", var, 0);
								sizeRA ++;
							}
						}
					}

					TemporalFactoryIF tf = new TemporalFactory(scope);
					TemporalIF temp = tf.create();
					
					cb.addQuadruple("GLOBALPOINTER", temp, sizeRA);
				}

				int addressRA = 4;

				int symbols = 0;

				for ( SymbolIF symbol: scope.getSymbolTable().getSymbols() )
				{
					if ( symbol instanceof SymbolParameter ) 
					{
						int pos = ((SymbolParameter) symbol).getPosition();
						((SymbolParameter) symbol).setAddress(addressRA + pos);				
						symbols ++;
					}
				}
				
				addressRA += symbols;

				if ( scope.getLevel() != 0 ) addressRA++;

				for ( SymbolIF symbol: scope.getSymbolTable().getSymbols() )
				{
					if ( symbol instanceof SymbolVariable ) 
					{
						((SymbolVariable) symbol).setAddress(addressRA);
						addressRA += symbol.getType().getSize();
					}
				}

				for ( TemporalIF temporal: scope.getTemporalTable().getTemporals() )
				{
					if ( temporal instanceof Temporal ) 
					{
						((Temporal) temporal).setAddress(addressRA);					
						addressRA += ((Temporal) temporal).getSize();
					}
				}

				cb.addQuadruples(ax.getIntermediateCode());
				
				if ( scope.getLevel() == 0 ) cb.addQuadruples(stringList);

				ax.setIntermediateCode(cb.create());
			}

	  		// No modificar esta estructura, aunque se pueden a�adir mas acciones semanticas
	
	  		List intermediateCode = ax.getIntermediateCode ();
			finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
	  		finalCodeFactory.create (intermediateCode);

	  		// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
	  		// en las llamadas a cupTest si el compilador no esta completo. Esto es debido a que 
	  		// aun no se tendra implementada la generacion de codigo intermedio ni final.
	  		// Para la entrega final deberan descomentarse y usarse.
	  		
	  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
	  	
              CUP$parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              Object RESULT =null;
 
  		    syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
  		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$0",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

